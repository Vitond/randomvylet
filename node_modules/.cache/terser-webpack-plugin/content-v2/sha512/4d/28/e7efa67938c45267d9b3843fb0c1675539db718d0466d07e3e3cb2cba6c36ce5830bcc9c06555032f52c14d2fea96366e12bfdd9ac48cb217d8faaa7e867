{"map":"{\"version\":3,\"sources\":[\"index.js\"],\"names\":[\"modules\",\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"enumerable\",\"get\",\"r\",\"Symbol\",\"toStringTag\",\"value\",\"t\",\"mode\",\"__esModule\",\"ns\",\"create\",\"key\",\"bind\",\"n\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\",\"__webpack_exports__\",\"eval\"],\"mappings\":\"CAAS,SAAUA,GAET,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAJ,EAAQG,GAAUK,KAAKH,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBO,EAAIT,EAGxBE,EAAoBQ,EAAIT,EAGxBC,EAAoBS,EAAI,SAASP,EAASQ,EAAMC,GAC3CX,EAAoBY,EAAEV,EAASQ,IAClCG,OAAOC,eAAeZ,EAASQ,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEX,EAAoBiB,EAAI,SAASf,GACX,oBAAXgB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeZ,EAASgB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeZ,EAAS,aAAc,CAAEkB,OAAO,KAQvDpB,EAAoBqB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQpB,EAAoBoB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAzB,EAAoBiB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOpB,EAAoBS,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRxB,EAAoB4B,EAAI,SAASzB,GAChC,IAAIQ,EAASR,GAAUA,EAAOoB,WAC7B,WAAwB,OAAOpB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBS,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRX,EAAoBY,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG9B,EAAoBiC,EAAI,GAIjBjC,EAAoBA,EAAoBkC,EAAI,GAnFpD,CAsFC,CAEJ,SAAU/B,OAAQgC,oBAAqBnC,qBAE7C,aACAoC,KAAK\"}","code":"!function(n){var g={};function e(t){if(g[t])return g[t].exports;var I=g[t]={i:t,l:!1,exports:{}};return n[t].call(I.exports,I,I.exports,e),I.l=!0,I.exports}e.m=n,e.c=g,e.d=function(n,g,t){e.o(n,g)||Object.defineProperty(n,g,{enumerable:!0,get:t})},e.r=function(n){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(n,\"__esModule\",{value:!0})},e.t=function(n,g){if(1&g&&(n=e(n)),8&g)return n;if(4&g&&\"object\"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(e.r(t),Object.defineProperty(t,\"default\",{enumerable:!0,value:n}),2&g&&\"string\"!=typeof n)for(var I in n)e.d(t,I,function(g){return n[g]}.bind(null,I));return t},e.n=function(n){var g=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(g,\"a\",g),g},e.o=function(n,g){return Object.prototype.hasOwnProperty.call(n,g)},e.p=\"\",e(e.s=0)}([function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"// ESM COMPAT FLAG\\n__webpack_require__.r(__webpack_exports__);\\n\\n// CONCATENATED MODULE: ./src/js/functions.js\\n// Rendering the element or removing it from the screen smoothly - with animations\\n// The element must have 3 CSS Classes available - hidden class, visible class, hiding class\\n// Hidden class - display: none, no animation\\n// Visible class - display: block (or whatever except none) and an animation of the element appearing on the page (sliding -in or so)\\n// Hiding class - animation of the element disappearing\\n// Element has only one of these classes at a time.\\n// The hiding class is changed to hidden class after 'animationend' event on the element\\nconst showOrHideEl = (element, hiddenClass, visibleClass, hidingClass) => {\\n    if([...element.classList].includes(hiddenClass)) {\\n\\n        element.classList.remove(hiddenClass);\\n        element.classList.add(visibleClass);\\n\\n    } else {\\n\\n        element.classList.remove(visibleClass);\\n        element.classList.add(hidingClass);\\n\\n        const animationEndHandler =  function(event) {\\n        if(event.pseudoElement) {\\n            element.addEventListener('animationend', animationEndHandler,  {\\n            capture: false,\\n            once: true,\\n            passive: false\\n            });\\n            return;\\n        }\\n\\n        element.classList.remove(hidingClass);\\n        element.classList.add(hiddenClass);\\n\\n        }\\n\\n        element.addEventListener('animationend', animationEndHandler, {\\n        capture: false,\\n        once: true,\\n        passive: false\\n        });\\n    }\\n}\\n\\n// Renders map to an element with id 'map'\\nfunction createMap(lng, lat) {\\n    \\n    const pos = {'lat': lat, 'lng': lng};\\n    \\n    const map = new google.maps.Map(document.getElementById('map'), {\\n      zoom: 12,\\n      center: pos\\n    });\\n    \\n    const marker = new google.maps.Marker({\\n      position: pos,\\n      map: map\\n    });\\n    \\n  } \\n\\n// Sends request to Google Geocoding API and returns coords for the sent address\\nconst getCoordsFromAddress = async (address) => {\\n\\n    // Encoding address for URL usage\\n    const urlAddress = encodeURI(address);\\n\\n    // Sending request\\n    const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?address=${urlAddress},+Mountain+View,+CA&key=AIzaSyDmi1OHuKzeuT3xbKkcgBQ4C6FEC9CN6hE`);\\n    //Parsing\\n    const data = await response.json();\\n\\n    // Returning coords for the best result\\n    const coordinates = data.results[0].geometry.location;\\n\\n    if(!coordinates) {\\n        throw new Error('Getting the coords from google geocoding API failed');\\n    }\\n\\n    return coordinates;\\n}\\n\\n// Converting kilometers to deg (1 deg means cca 111km)\\nconst convertKmToDeg = kilometers => kilometers/111;\\n\\n// Switching input whenever the user chooses his preferable input option by adding and removing hidden classes\\nconst changeInputType = (firstInputSet, secondInputSet, checkfor , e) => {\\n\\n    if (e.target.value === checkfor) {\\n        firstInputSet.classList.remove('hidden');\\n        secondInputSet.classList.add('hidden');\\n       \\n    } else {\\n        firstInputSet.classList.add('hidden');\\n        secondInputSet.classList.remove('hidden');\\n    }\\n\\n}\\n\\n// Getting coordinates from the user input\\nconst getCoords = async (addressRadio, formEls) => {\\n\\n    let lng;\\n    let lat;\\n\\n    // If !adressRadio.checked = if the user has selected coords for getting address\\n    if(!addressRadio.checked) {\\n\\n        // Getiting coords from the coords input\\n        lng = +formEls['coord-long'].value;\\n        lat = +formEls['coord-lat'].value;\\n\\n    } else {\\n\\n        //Getting address from the address input \\n        const address = formEls['address'].value;\\n\\n        // Sending request to the Google Geocoding API and geting coords for the address\\n        try {\\n            const coords = await getCoordsFromAddress(address);\\n\\n            lng = coords.lng;\\n            lat = coords.lat;\\n\\n        } catch (err) {\\n            throw new Error(err);\\n        }\\n       \\n    }\\n\\n    return [lng, lat];\\n}\\n\\nconst calculateCoordTransform = (circleRadio, formEls, coords) => {\\n\\n    const [lat, lng] = coords;\\n\\n    let range;\\n    let randomDist;\\n\\n    // Selecting random angle\\n    const randomAngle  = Math.random() * 2 * Math.PI\\n\\n    //If circleRadio.checked = if the user has choosen the circle\\n    if(circleRadio.checked) {\\n\\n        // Selecting random distance from base in the selected circle range\\n        range = +formEls['circle-perimeter'].value;\\n        randomDist = range * Math.random();\\n        \\n    } else {\\n\\n        // Selecting random distance from base in the selected annulus range\\n        range = +formEls['annulus-perimeter-outer'].value - +formEls['annulus-perimeter-inner'].value;\\n        randomDist = +formEls['annulus-perimeter-inner'].value + range * Math.random();\\n\\n    }\\n\\n    // Getting the offset from base latitude and base longitude in kilometers\\n    const moveLngKm = Math.sin(randomAngle)*randomDist;\\n    const moveLatKm = Math.cos(randomAngle)*randomDist;\\n\\n    // Converting to degrees\\n    const moveLng = convertKmToDeg(moveLngKm);\\n    const moveLat = convertKmToDeg(moveLatKm);\\n\\n    // Applying the offset\\n    const finalLng = lng + moveLng;\\n    const finalLat = lat + moveLat;\\n\\n    return [finalLat, finalLng];\\n\\n}\\n\\n// Adds invalid class if the input isnt valid, returns true || false , depending on if the input is valid or not\\nconst validateInput = (input, formEls) => {\\n\\n    // Returning if the input type is radio\\n    if(input.type === 'radio') {\\n        return;\\n    }\\n\\n    let valid;\\n\\n    // If the input is address, checking if it is not an empty string\\n    // If the input is not address, checking, if the input value is a number \\n    if(input === formEls['address']) {\\n        valid = input.value.trim();\\n    } else {\\n        const numberRegex = /^[0-9]+(\\\\.[0-9])*$/;\\n        valid = numberRegex.test(input.value);\\n    }\\n\\n    // Adding invalid class if the input is invalid, removing it, if the input is not\\n    if (valid) {\\n        input.classList.remove('invalid');\\n    } else {\\n        input.classList.add('invalid');\\n    }\\n\\n    return valid;\\n}\\n\\n// Validates all inputs, that are required to create Map, based on what the user selected\\nconst validateNeeded = (addressRadio, circleRadio, formEls) => {\\n\\n\\n    let validateList = [];\\n\\n    if (addressRadio.checked) {\\n        validateList.push(formEls['address']);\\n    } else {\\n        validateList.push(formEls['coord-lng']);\\n        validateList.push(formEls['coord-lat']);\\n    }\\n\\n    if (circleRadio.checked) {\\n        validateList.push(formEls['circle-perimeter']);\\n    } else {\\n        validateList.push(formEls['annulus-perimeter-outer']);\\n        validateList.push(formEls['annulus-perimeter-inner']);\\n    }\\n\\n    let valid = true;\\n\\n    for (const input of validateList) {\\n        \\n        const isInputValid = validateInput(input, formEls);\\n\\n        if(!isInputValid) {\\n            valid = false;\\n        }\\n\\n    }\\n\\n    return valid;\\n}\\n// CONCATENATED MODULE: ./src/js/index.js\\n\\n\\nconst js_form = document.querySelector('form');\\n\\n////// IF THE CURRENT PAGE IS INDEX\\nif(js_form) {\\n\\n    // Accessing formEls \\n    const formEls = js_form.elements;\\n\\n    // Selecting address initially, getting adressRadio, which is then being used for getting input values\\n    const addressRadio = document.getElementById('locationselect-adr');\\n    addressRadio.checked = true;\\n\\n    // Selecting circle initially , getting circleRadio, which is then being used for getting input values\\n    const circleRadio = document.getElementById('rangeselect-circle');\\n    circleRadio.checked = true;\\n\\n    // Activating show info about the application button\\n    const info = document.getElementById('info');\\n    const infoBtn = document.getElementById('show-info');\\n    infoBtn.addEventListener('click', () => {\\n        showOrHideEl(info, 'info--hidden', 'info--visible', 'info--hiding'); // Changes button styling\\n        showOrHideEl(infoBtn, 'header__btn--not-clicked', 'header__btn--clicked', 'header__btn--hiding'); //Shows or hides the info div\\n    })\\n\\n    // Setting up the refresh map button\\n    const refreshBtn = document.getElementById('refresh');\\n    refreshBtn.addEventListener('click', async () => {\\n\\n        const formEls = js_form.elements;\\n        let coords;\\n        \\n        try {\\n\\n            //Getting coords\\n            coords = await getCoords(addressRadio, formEls);\\n\\n        } catch (err) {\\n\\n            const errorDiv = document.getElementById('error'); \\n            errorDiv.textContent = 'Nepodařilo se získat souřadnice. Zkuste to znovu později.'\\n\\n            return;\\n\\n        }\\n        try {\\n\\n            // Rendering map to the screen\\n            createMap(...coords);\\n\\n        } catch {\\n\\n            const errorDiv = document.getElementById('error'); \\n            errorDiv.textContent = 'Nepodařilo se získat mapu. Zkuste to znovu později'\\n        }\\n    })\\n\\n    //Showing the proper input(s) whenever the user chooses if he wants to get the base location by adress or by coords\\n    const locationSelect  = document.getElementById('locationselect-adr').parentElement.parentElement;\\n    const addressInputSet = document.getElementById('address').closest('.form__set');\\n    const coordInputSet = document.getElementById('coord-lat').closest('.form__set');\\n\\n    locationSelect.addEventListener('input', (e) => {\\n        changeInputType(addressInputSet, coordInputSet, 'adr', e);\\n    })\\n\\n    //Showing the proper input(s) whenever the user chooses if he wants to find a trip place in a circle or in an annulus\\n    const rangeSelect = document.getElementById('rangeselect-circle').parentElement.parentElement;\\n    const annulusInputSet = document.getElementById('annulus-perimeter-outer').closest('.form__set');\\n    const circleInputSet = document.getElementById('circle-perimeter').closest('.form__set');\\n\\n    rangeSelect.addEventListener('input', (e) => {\\n        changeInputType(annulusInputSet, circleInputSet, 'annulus', e);\\n    })\\n\\n    //Form submit handling\\n    js_form.addEventListener('submit', async (e) => {\\n\\n        e.preventDefault();\\n\\n        // Finding out, if all needet inputs are valid\\n        const areInputsValid = validateNeeded(addressRadio, circleRadio, formEls);\\n\\n        // Executing logic when all needed inputs are valid\\n        if  (areInputsValid) {\\n\\n            // Getting coords for the selected base\\n            let coords;\\n\\n            try {\\n\\n                //Getting coords\\n                coords = await getCoords(addressRadio, formEls);\\n    \\n            } catch (err) {\\n    \\n                const errorDiv = document.getElementById('error'); \\n                errorDiv.textContent = 'Nepodařilo se získat souřadnice. Zkuste to znovu později.'\\n\\n                return;\\n    \\n            }\\n            \\n            // Getting coords of a random place in the selected range\\n            const [finalLng, finalLat] = calculateCoordTransform(circleRadio, formEls, coords);\\n            \\n            // Constructing URL and redirecting the user to the 'found' page\\n            const url = new URL(`/views/found.html?lng=${finalLng}&lat=${finalLat}`, document.location.href);\\n            document.location.href = url;\\n\\n        } else {\\n\\n            const errorDiv = document.getElementById('error');\\n            if (addressRadio.checked) {\\n                errorDiv.textContent = 'Alespoň jeden input je neplatný. Zkontrolujte, prosím, zda jste zadali adresu a zda jsou všechna čísla zadaná bez jednotek a případné desetinné řády jsou oddělené tečkou.';\\n            } else {\\n                errorDiv.textContent = 'Alespoň jeden input je neplatný. Zkontrolujte, prosím, zda jsou všechna čísla zadaná bez jednotek a případné desetinné řády jsou oddělené tečkou';\\n            }\\n\\n        }\\n    })\\n\\n    // Validating input, whenever the user enters sth to it\\n    for (const input of js_form.elements) {\\n        input.addEventListener('input', () => {\\n            validateInput(input, formEls);\\n        })\\n    }\\n}\\n\\nconst found = document.querySelector('.found');\\n\\n////// IF THE CURRENT PAGE IS FOUND\\n\\nif(found) {\\n\\n    //Getting longitude and latitude from URLSearchParams\\n    const params = new URLSearchParams(window.location.search);\\n    const lat = +params.get('lat');\\n    const lng = +params.get('lng');\\n    \\n    //Finding elements, where the resultcoords will be rendered\\n    const latEl = document.querySelector('.found__coord-lat');\\n    const lngEl = document.querySelector('.found__coord-long');\\n    \\n    // Rendering the result coords\\n    latEl.textContent = lat;\\n    lngEl.textContent = lng;\\n    \\n    // Creating a map with result coords in the center\\n\\n    try {\\n\\n        //Rendering map\\n        createMap(lng, lat);\\n\\n    } catch (err) {\\n\\n        const errorDiv = document.getElementById('error'); \\n        errorDiv.textContent = 'Nepodařilo se získat mapu. Zkuste to znovu později.'\\n\\n    }\\n   \\n    // When user clicks the button, he gets redirected to index.html\\n    const nextTripBtn = document.querySelector('button');\\n    nextTripBtn.addEventListener('click', () => {\\n        const url = new URL(`/views`, document.location.href);\\n        document.location.href = url;\\n    })\\n}\\n\\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9mdW5jdGlvbnMuanM/YmUwNCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaW5kZXguanM/N2JhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZW5kZXJpbmcgdGhlIGVsZW1lbnQgb3IgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgc2NyZWVuIHNtb290aGx5IC0gd2l0aCBhbmltYXRpb25zXG4vLyBUaGUgZWxlbWVudCBtdXN0IGhhdmUgMyBDU1MgQ2xhc3NlcyBhdmFpbGFibGUgLSBoaWRkZW4gY2xhc3MsIHZpc2libGUgY2xhc3MsIGhpZGluZyBjbGFzc1xuLy8gSGlkZGVuIGNsYXNzIC0gZGlzcGxheTogbm9uZSwgbm8gYW5pbWF0aW9uXG4vLyBWaXNpYmxlIGNsYXNzIC0gZGlzcGxheTogYmxvY2sgKG9yIHdoYXRldmVyIGV4Y2VwdCBub25lKSBhbmQgYW4gYW5pbWF0aW9uIG9mIHRoZSBlbGVtZW50IGFwcGVhcmluZyBvbiB0aGUgcGFnZSAoc2xpZGluZyAtaW4gb3Igc28pXG4vLyBIaWRpbmcgY2xhc3MgLSBhbmltYXRpb24gb2YgdGhlIGVsZW1lbnQgZGlzYXBwZWFyaW5nXG4vLyBFbGVtZW50IGhhcyBvbmx5IG9uZSBvZiB0aGVzZSBjbGFzc2VzIGF0IGEgdGltZS5cbi8vIFRoZSBoaWRpbmcgY2xhc3MgaXMgY2hhbmdlZCB0byBoaWRkZW4gY2xhc3MgYWZ0ZXIgJ2FuaW1hdGlvbmVuZCcgZXZlbnQgb24gdGhlIGVsZW1lbnRcbmV4cG9ydCBjb25zdCBzaG93T3JIaWRlRWwgPSAoZWxlbWVudCwgaGlkZGVuQ2xhc3MsIHZpc2libGVDbGFzcywgaGlkaW5nQ2xhc3MpID0+IHtcbiAgICBpZihbLi4uZWxlbWVudC5jbGFzc0xpc3RdLmluY2x1ZGVzKGhpZGRlbkNsYXNzKSkge1xuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShoaWRkZW5DbGFzcyk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCh2aXNpYmxlQ2xhc3MpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodmlzaWJsZUNsYXNzKTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGhpZGluZ0NsYXNzKTtcblxuICAgICAgICBjb25zdCBhbmltYXRpb25FbmRIYW5kbGVyID0gIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmKGV2ZW50LnBzZXVkb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgYW5pbWF0aW9uRW5kSGFuZGxlciwgIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShoaWRpbmdDbGFzcyk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChoaWRkZW5DbGFzcyk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgYW5pbWF0aW9uRW5kSGFuZGxlciwge1xuICAgICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vLyBSZW5kZXJzIG1hcCB0byBhbiBlbGVtZW50IHdpdGggaWQgJ21hcCdcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAobG5nLCBsYXQpIHtcbiAgICBcbiAgICBjb25zdCBwb3MgPSB7J2xhdCc6IGxhdCwgJ2xuZyc6IGxuZ307XG4gICAgXG4gICAgY29uc3QgbWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFwJyksIHtcbiAgICAgIHpvb206IDEyLFxuICAgICAgY2VudGVyOiBwb3NcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBtYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKHtcbiAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICBtYXA6IG1hcFxuICAgIH0pO1xuICAgIFxuICB9IFxuXG4vLyBTZW5kcyByZXF1ZXN0IHRvIEdvb2dsZSBHZW9jb2RpbmcgQVBJIGFuZCByZXR1cm5zIGNvb3JkcyBmb3IgdGhlIHNlbnQgYWRkcmVzc1xuZXhwb3J0IGNvbnN0IGdldENvb3Jkc0Zyb21BZGRyZXNzID0gYXN5bmMgKGFkZHJlc3MpID0+IHtcblxuICAgIC8vIEVuY29kaW5nIGFkZHJlc3MgZm9yIFVSTCB1c2FnZVxuICAgIGNvbnN0IHVybEFkZHJlc3MgPSBlbmNvZGVVUkkoYWRkcmVzcyk7XG5cbiAgICAvLyBTZW5kaW5nIHJlcXVlc3RcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvZ2VvY29kZS9qc29uP2FkZHJlc3M9JHt1cmxBZGRyZXNzfSwrTW91bnRhaW4rVmlldywrQ0Ema2V5PUFJemFTeURtaTFPSHVLemV1VDN4YktrY2dCUTRDNkZFQzlDTjZoRWApO1xuICAgIC8vUGFyc2luZ1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAvLyBSZXR1cm5pbmcgY29vcmRzIGZvciB0aGUgYmVzdCByZXN1bHRcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IGRhdGEucmVzdWx0c1swXS5nZW9tZXRyeS5sb2NhdGlvbjtcblxuICAgIGlmKCFjb29yZGluYXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dldHRpbmcgdGhlIGNvb3JkcyBmcm9tIGdvb2dsZSBnZW9jb2RpbmcgQVBJIGZhaWxlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBjb29yZGluYXRlcztcbn1cblxuLy8gQ29udmVydGluZyBraWxvbWV0ZXJzIHRvIGRlZyAoMSBkZWcgbWVhbnMgY2NhIDExMWttKVxuZXhwb3J0IGNvbnN0IGNvbnZlcnRLbVRvRGVnID0ga2lsb21ldGVycyA9PiBraWxvbWV0ZXJzLzExMTtcblxuLy8gU3dpdGNoaW5nIGlucHV0IHdoZW5ldmVyIHRoZSB1c2VyIGNob29zZXMgaGlzIHByZWZlcmFibGUgaW5wdXQgb3B0aW9uIGJ5IGFkZGluZyBhbmQgcmVtb3ZpbmcgaGlkZGVuIGNsYXNzZXNcbmV4cG9ydCBjb25zdCBjaGFuZ2VJbnB1dFR5cGUgPSAoZmlyc3RJbnB1dFNldCwgc2Vjb25kSW5wdXRTZXQsIGNoZWNrZm9yICwgZSkgPT4ge1xuXG4gICAgaWYgKGUudGFyZ2V0LnZhbHVlID09PSBjaGVja2Zvcikge1xuICAgICAgICBmaXJzdElucHV0U2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICBzZWNvbmRJbnB1dFNldC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdElucHV0U2V0LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICBzZWNvbmRJbnB1dFNldC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICB9XG5cbn1cblxuLy8gR2V0dGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSB1c2VyIGlucHV0XG5leHBvcnQgY29uc3QgZ2V0Q29vcmRzID0gYXN5bmMgKGFkZHJlc3NSYWRpbywgZm9ybUVscykgPT4ge1xuXG4gICAgbGV0IGxuZztcbiAgICBsZXQgbGF0O1xuXG4gICAgLy8gSWYgIWFkcmVzc1JhZGlvLmNoZWNrZWQgPSBpZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgY29vcmRzIGZvciBnZXR0aW5nIGFkZHJlc3NcbiAgICBpZighYWRkcmVzc1JhZGlvLmNoZWNrZWQpIHtcblxuICAgICAgICAvLyBHZXRpdGluZyBjb29yZHMgZnJvbSB0aGUgY29vcmRzIGlucHV0XG4gICAgICAgIGxuZyA9ICtmb3JtRWxzWydjb29yZC1sb25nJ10udmFsdWU7XG4gICAgICAgIGxhdCA9ICtmb3JtRWxzWydjb29yZC1sYXQnXS52YWx1ZTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy9HZXR0aW5nIGFkZHJlc3MgZnJvbSB0aGUgYWRkcmVzcyBpbnB1dCBcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGZvcm1FbHNbJ2FkZHJlc3MnXS52YWx1ZTtcblxuICAgICAgICAvLyBTZW5kaW5nIHJlcXVlc3QgdG8gdGhlIEdvb2dsZSBHZW9jb2RpbmcgQVBJIGFuZCBnZXRpbmcgY29vcmRzIGZvciB0aGUgYWRkcmVzc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29vcmRzID0gYXdhaXQgZ2V0Q29vcmRzRnJvbUFkZHJlc3MoYWRkcmVzcyk7XG5cbiAgICAgICAgICAgIGxuZyA9IGNvb3Jkcy5sbmc7XG4gICAgICAgICAgICBsYXQgPSBjb29yZHMubGF0O1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICBcbiAgICB9XG5cbiAgICByZXR1cm4gW2xuZywgbGF0XTtcbn1cblxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZUNvb3JkVHJhbnNmb3JtID0gKGNpcmNsZVJhZGlvLCBmb3JtRWxzLCBjb29yZHMpID0+IHtcblxuICAgIGNvbnN0IFtsYXQsIGxuZ10gPSBjb29yZHM7XG5cbiAgICBsZXQgcmFuZ2U7XG4gICAgbGV0IHJhbmRvbURpc3Q7XG5cbiAgICAvLyBTZWxlY3RpbmcgcmFuZG9tIGFuZ2xlXG4gICAgY29uc3QgcmFuZG9tQW5nbGUgID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJXG5cbiAgICAvL0lmIGNpcmNsZVJhZGlvLmNoZWNrZWQgPSBpZiB0aGUgdXNlciBoYXMgY2hvb3NlbiB0aGUgY2lyY2xlXG4gICAgaWYoY2lyY2xlUmFkaW8uY2hlY2tlZCkge1xuXG4gICAgICAgIC8vIFNlbGVjdGluZyByYW5kb20gZGlzdGFuY2UgZnJvbSBiYXNlIGluIHRoZSBzZWxlY3RlZCBjaXJjbGUgcmFuZ2VcbiAgICAgICAgcmFuZ2UgPSArZm9ybUVsc1snY2lyY2xlLXBlcmltZXRlciddLnZhbHVlO1xuICAgICAgICByYW5kb21EaXN0ID0gcmFuZ2UgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICBcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFNlbGVjdGluZyByYW5kb20gZGlzdGFuY2UgZnJvbSBiYXNlIGluIHRoZSBzZWxlY3RlZCBhbm51bHVzIHJhbmdlXG4gICAgICAgIHJhbmdlID0gK2Zvcm1FbHNbJ2FubnVsdXMtcGVyaW1ldGVyLW91dGVyJ10udmFsdWUgLSArZm9ybUVsc1snYW5udWx1cy1wZXJpbWV0ZXItaW5uZXInXS52YWx1ZTtcbiAgICAgICAgcmFuZG9tRGlzdCA9ICtmb3JtRWxzWydhbm51bHVzLXBlcmltZXRlci1pbm5lciddLnZhbHVlICsgcmFuZ2UgKiBNYXRoLnJhbmRvbSgpO1xuXG4gICAgfVxuXG4gICAgLy8gR2V0dGluZyB0aGUgb2Zmc2V0IGZyb20gYmFzZSBsYXRpdHVkZSBhbmQgYmFzZSBsb25naXR1ZGUgaW4ga2lsb21ldGVyc1xuICAgIGNvbnN0IG1vdmVMbmdLbSA9IE1hdGguc2luKHJhbmRvbUFuZ2xlKSpyYW5kb21EaXN0O1xuICAgIGNvbnN0IG1vdmVMYXRLbSA9IE1hdGguY29zKHJhbmRvbUFuZ2xlKSpyYW5kb21EaXN0O1xuXG4gICAgLy8gQ29udmVydGluZyB0byBkZWdyZWVzXG4gICAgY29uc3QgbW92ZUxuZyA9IGNvbnZlcnRLbVRvRGVnKG1vdmVMbmdLbSk7XG4gICAgY29uc3QgbW92ZUxhdCA9IGNvbnZlcnRLbVRvRGVnKG1vdmVMYXRLbSk7XG5cbiAgICAvLyBBcHBseWluZyB0aGUgb2Zmc2V0XG4gICAgY29uc3QgZmluYWxMbmcgPSBsbmcgKyBtb3ZlTG5nO1xuICAgIGNvbnN0IGZpbmFsTGF0ID0gbGF0ICsgbW92ZUxhdDtcblxuICAgIHJldHVybiBbZmluYWxMYXQsIGZpbmFsTG5nXTtcblxufVxuXG4vLyBBZGRzIGludmFsaWQgY2xhc3MgaWYgdGhlIGlucHV0IGlzbnQgdmFsaWQsIHJldHVybnMgdHJ1ZSB8fCBmYWxzZSAsIGRlcGVuZGluZyBvbiBpZiB0aGUgaW5wdXQgaXMgdmFsaWQgb3Igbm90XG5leHBvcnQgY29uc3QgdmFsaWRhdGVJbnB1dCA9IChpbnB1dCwgZm9ybUVscykgPT4ge1xuXG4gICAgLy8gUmV0dXJuaW5nIGlmIHRoZSBpbnB1dCB0eXBlIGlzIHJhZGlvXG4gICAgaWYoaW5wdXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHZhbGlkO1xuXG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIGFkZHJlc3MsIGNoZWNraW5nIGlmIGl0IGlzIG5vdCBhbiBlbXB0eSBzdHJpbmdcbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgbm90IGFkZHJlc3MsIGNoZWNraW5nLCBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgYSBudW1iZXIgXG4gICAgaWYoaW5wdXQgPT09IGZvcm1FbHNbJ2FkZHJlc3MnXSkge1xuICAgICAgICB2YWxpZCA9IGlucHV0LnZhbHVlLnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBudW1iZXJSZWdleCA9IC9eWzAtOV0rKFxcLlswLTldKSokLztcbiAgICAgICAgdmFsaWQgPSBudW1iZXJSZWdleC50ZXN0KGlucHV0LnZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBBZGRpbmcgaW52YWxpZCBjbGFzcyBpZiB0aGUgaW5wdXQgaXMgaW52YWxpZCwgcmVtb3ZpbmcgaXQsIGlmIHRoZSBpbnB1dCBpcyBub3RcbiAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSgnaW52YWxpZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2ludmFsaWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWQ7XG59XG5cbi8vIFZhbGlkYXRlcyBhbGwgaW5wdXRzLCB0aGF0IGFyZSByZXF1aXJlZCB0byBjcmVhdGUgTWFwLCBiYXNlZCBvbiB3aGF0IHRoZSB1c2VyIHNlbGVjdGVkXG5leHBvcnQgY29uc3QgdmFsaWRhdGVOZWVkZWQgPSAoYWRkcmVzc1JhZGlvLCBjaXJjbGVSYWRpbywgZm9ybUVscykgPT4ge1xuXG5cbiAgICBsZXQgdmFsaWRhdGVMaXN0ID0gW107XG5cbiAgICBpZiAoYWRkcmVzc1JhZGlvLmNoZWNrZWQpIHtcbiAgICAgICAgdmFsaWRhdGVMaXN0LnB1c2goZm9ybUVsc1snYWRkcmVzcyddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0ZUxpc3QucHVzaChmb3JtRWxzWydjb29yZC1sbmcnXSk7XG4gICAgICAgIHZhbGlkYXRlTGlzdC5wdXNoKGZvcm1FbHNbJ2Nvb3JkLWxhdCddKTtcbiAgICB9XG5cbiAgICBpZiAoY2lyY2xlUmFkaW8uY2hlY2tlZCkge1xuICAgICAgICB2YWxpZGF0ZUxpc3QucHVzaChmb3JtRWxzWydjaXJjbGUtcGVyaW1ldGVyJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRlTGlzdC5wdXNoKGZvcm1FbHNbJ2FubnVsdXMtcGVyaW1ldGVyLW91dGVyJ10pO1xuICAgICAgICB2YWxpZGF0ZUxpc3QucHVzaChmb3JtRWxzWydhbm51bHVzLXBlcmltZXRlci1pbm5lciddKTtcbiAgICB9XG5cbiAgICBsZXQgdmFsaWQgPSB0cnVlO1xuXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiB2YWxpZGF0ZUxpc3QpIHtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGlzSW5wdXRWYWxpZCA9IHZhbGlkYXRlSW5wdXQoaW5wdXQsIGZvcm1FbHMpO1xuXG4gICAgICAgIGlmKCFpc0lucHV0VmFsaWQpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZDtcbn0iLCJpbXBvcnQgKiBhcyBmY25zIGZyb20gJy4vZnVuY3Rpb25zLmpzJztcblxuY29uc3QgZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Zvcm0nKTtcblxuLy8vLy8vIElGIFRIRSBDVVJSRU5UIFBBR0UgSVMgSU5ERVhcbmlmKGZvcm0pIHtcblxuICAgIC8vIEFjY2Vzc2luZyBmb3JtRWxzIFxuICAgIGNvbnN0IGZvcm1FbHMgPSBmb3JtLmVsZW1lbnRzO1xuXG4gICAgLy8gU2VsZWN0aW5nIGFkZHJlc3MgaW5pdGlhbGx5LCBnZXR0aW5nIGFkcmVzc1JhZGlvLCB3aGljaCBpcyB0aGVuIGJlaW5nIHVzZWQgZm9yIGdldHRpbmcgaW5wdXQgdmFsdWVzXG4gICAgY29uc3QgYWRkcmVzc1JhZGlvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvY2F0aW9uc2VsZWN0LWFkcicpO1xuICAgIGFkZHJlc3NSYWRpby5jaGVja2VkID0gdHJ1ZTtcblxuICAgIC8vIFNlbGVjdGluZyBjaXJjbGUgaW5pdGlhbGx5ICwgZ2V0dGluZyBjaXJjbGVSYWRpbywgd2hpY2ggaXMgdGhlbiBiZWluZyB1c2VkIGZvciBnZXR0aW5nIGlucHV0IHZhbHVlc1xuICAgIGNvbnN0IGNpcmNsZVJhZGlvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jhbmdlc2VsZWN0LWNpcmNsZScpO1xuICAgIGNpcmNsZVJhZGlvLmNoZWNrZWQgPSB0cnVlO1xuXG4gICAgLy8gQWN0aXZhdGluZyBzaG93IGluZm8gYWJvdXQgdGhlIGFwcGxpY2F0aW9uIGJ1dHRvblxuICAgIGNvbnN0IGluZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5mbycpO1xuICAgIGNvbnN0IGluZm9CdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2hvdy1pbmZvJyk7XG4gICAgaW5mb0J0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgZmNucy5zaG93T3JIaWRlRWwoaW5mbywgJ2luZm8tLWhpZGRlbicsICdpbmZvLS12aXNpYmxlJywgJ2luZm8tLWhpZGluZycpOyAvLyBDaGFuZ2VzIGJ1dHRvbiBzdHlsaW5nXG4gICAgICAgIGZjbnMuc2hvd09ySGlkZUVsKGluZm9CdG4sICdoZWFkZXJfX2J0bi0tbm90LWNsaWNrZWQnLCAnaGVhZGVyX19idG4tLWNsaWNrZWQnLCAnaGVhZGVyX19idG4tLWhpZGluZycpOyAvL1Nob3dzIG9yIGhpZGVzIHRoZSBpbmZvIGRpdlxuICAgIH0pXG5cbiAgICAvLyBTZXR0aW5nIHVwIHRoZSByZWZyZXNoIG1hcCBidXR0b25cbiAgICBjb25zdCByZWZyZXNoQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlZnJlc2gnKTtcbiAgICByZWZyZXNoQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGZvcm1FbHMgPSBmb3JtLmVsZW1lbnRzO1xuICAgICAgICBsZXQgY29vcmRzO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgLy9HZXR0aW5nIGNvb3Jkc1xuICAgICAgICAgICAgY29vcmRzID0gYXdhaXQgZmNucy5nZXRDb29yZHMoYWRkcmVzc1JhZGlvLCBmb3JtRWxzKTtcblxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcblxuICAgICAgICAgICAgY29uc3QgZXJyb3JEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3InKTsgXG4gICAgICAgICAgICBlcnJvckRpdi50ZXh0Q29udGVudCA9ICdOZXBvZGHFmWlsbyBzZSB6w61za2F0IHNvdcWZYWRuaWNlLiBaa3VzdGUgdG8gem5vdnUgcG96ZMSbamkuJ1xuXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAvLyBSZW5kZXJpbmcgbWFwIHRvIHRoZSBzY3JlZW5cbiAgICAgICAgICAgIGZjbnMuY3JlYXRlTWFwKC4uLmNvb3Jkcyk7XG5cbiAgICAgICAgfSBjYXRjaCB7XG5cbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yJyk7IFxuICAgICAgICAgICAgZXJyb3JEaXYudGV4dENvbnRlbnQgPSAnTmVwb2RhxZlpbG8gc2UgesOtc2thdCBtYXB1LiBaa3VzdGUgdG8gem5vdnUgcG96ZMSbamknXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLy9TaG93aW5nIHRoZSBwcm9wZXIgaW5wdXQocykgd2hlbmV2ZXIgdGhlIHVzZXIgY2hvb3NlcyBpZiBoZSB3YW50cyB0byBnZXQgdGhlIGJhc2UgbG9jYXRpb24gYnkgYWRyZXNzIG9yIGJ5IGNvb3Jkc1xuICAgIGNvbnN0IGxvY2F0aW9uU2VsZWN0ICA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbnNlbGVjdC1hZHInKS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgY29uc3QgYWRkcmVzc0lucHV0U2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZHJlc3MnKS5jbG9zZXN0KCcuZm9ybV9fc2V0Jyk7XG4gICAgY29uc3QgY29vcmRJbnB1dFNldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb29yZC1sYXQnKS5jbG9zZXN0KCcuZm9ybV9fc2V0Jyk7XG5cbiAgICBsb2NhdGlvblNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG4gICAgICAgIGZjbnMuY2hhbmdlSW5wdXRUeXBlKGFkZHJlc3NJbnB1dFNldCwgY29vcmRJbnB1dFNldCwgJ2FkcicsIGUpO1xuICAgIH0pXG5cbiAgICAvL1Nob3dpbmcgdGhlIHByb3BlciBpbnB1dChzKSB3aGVuZXZlciB0aGUgdXNlciBjaG9vc2VzIGlmIGhlIHdhbnRzIHRvIGZpbmQgYSB0cmlwIHBsYWNlIGluIGEgY2lyY2xlIG9yIGluIGFuIGFubnVsdXNcbiAgICBjb25zdCByYW5nZVNlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyYW5nZXNlbGVjdC1jaXJjbGUnKS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgY29uc3QgYW5udWx1c0lucHV0U2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FubnVsdXMtcGVyaW1ldGVyLW91dGVyJykuY2xvc2VzdCgnLmZvcm1fX3NldCcpO1xuICAgIGNvbnN0IGNpcmNsZUlucHV0U2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NpcmNsZS1wZXJpbWV0ZXInKS5jbG9zZXN0KCcuZm9ybV9fc2V0Jyk7XG5cbiAgICByYW5nZVNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG4gICAgICAgIGZjbnMuY2hhbmdlSW5wdXRUeXBlKGFubnVsdXNJbnB1dFNldCwgY2lyY2xlSW5wdXRTZXQsICdhbm51bHVzJywgZSk7XG4gICAgfSlcblxuICAgIC8vRm9ybSBzdWJtaXQgaGFuZGxpbmdcbiAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGFzeW5jIChlKSA9PiB7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIEZpbmRpbmcgb3V0LCBpZiBhbGwgbmVlZGV0IGlucHV0cyBhcmUgdmFsaWRcbiAgICAgICAgY29uc3QgYXJlSW5wdXRzVmFsaWQgPSBmY25zLnZhbGlkYXRlTmVlZGVkKGFkZHJlc3NSYWRpbywgY2lyY2xlUmFkaW8sIGZvcm1FbHMpO1xuXG4gICAgICAgIC8vIEV4ZWN1dGluZyBsb2dpYyB3aGVuIGFsbCBuZWVkZWQgaW5wdXRzIGFyZSB2YWxpZFxuICAgICAgICBpZiAgKGFyZUlucHV0c1ZhbGlkKSB7XG5cbiAgICAgICAgICAgIC8vIEdldHRpbmcgY29vcmRzIGZvciB0aGUgc2VsZWN0ZWQgYmFzZVxuICAgICAgICAgICAgbGV0IGNvb3JkcztcblxuICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgIC8vR2V0dGluZyBjb29yZHNcbiAgICAgICAgICAgICAgICBjb29yZHMgPSBhd2FpdCBmY25zLmdldENvb3JkcyhhZGRyZXNzUmFkaW8sIGZvcm1FbHMpO1xuICAgIFxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3InKTsgXG4gICAgICAgICAgICAgICAgZXJyb3JEaXYudGV4dENvbnRlbnQgPSAnTmVwb2RhxZlpbG8gc2UgesOtc2thdCBzb3XFmWFkbmljZS4gWmt1c3RlIHRvIHpub3Z1IHBvemTEm2ppLidcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0dGluZyBjb29yZHMgb2YgYSByYW5kb20gcGxhY2UgaW4gdGhlIHNlbGVjdGVkIHJhbmdlXG4gICAgICAgICAgICBjb25zdCBbZmluYWxMbmcsIGZpbmFsTGF0XSA9IGZjbnMuY2FsY3VsYXRlQ29vcmRUcmFuc2Zvcm0oY2lyY2xlUmFkaW8sIGZvcm1FbHMsIGNvb3Jkcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdGluZyBVUkwgYW5kIHJlZGlyZWN0aW5nIHRoZSB1c2VyIHRvIHRoZSAnZm91bmQnIHBhZ2VcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYC92aWV3cy9mb3VuZC5odG1sP2xuZz0ke2ZpbmFsTG5nfSZsYXQ9JHtmaW5hbExhdH1gLCBkb2N1bWVudC5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY29uc3QgZXJyb3JEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3InKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzUmFkaW8uY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGVycm9yRGl2LnRleHRDb250ZW50ID0gJ0FsZXNwb8WIIGplZGVuIGlucHV0IGplIG5lcGxhdG7DvS4gWmtvbnRyb2x1anRlLCBwcm9zw61tLCB6ZGEganN0ZSB6YWRhbGkgYWRyZXN1IGEgemRhIGpzb3UgdsWhZWNobmEgxI3DrXNsYSB6YWRhbsOhIGJleiBqZWRub3RlayBhIHDFmcOtcGFkbsOpIGRlc2V0aW5uw6kgxZnDoWR5IGpzb3Ugb2RkxJtsZW7DqSB0ZcSNa291Lic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yRGl2LnRleHRDb250ZW50ID0gJ0FsZXNwb8WIIGplZGVuIGlucHV0IGplIG5lcGxhdG7DvS4gWmtvbnRyb2x1anRlLCBwcm9zw61tLCB6ZGEganNvdSB2xaFlY2huYSDEjcOtc2xhIHphZGFuw6EgYmV6IGplZG5vdGVrIGEgcMWZw61wYWRuw6kgZGVzZXRpbm7DqSDFmcOhZHkganNvdSBvZGTEm2xlbsOpIHRlxI1rb3UnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVmFsaWRhdGluZyBpbnB1dCwgd2hlbmV2ZXIgdGhlIHVzZXIgZW50ZXJzIHN0aCB0byBpdFxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgZm9ybS5lbGVtZW50cykge1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcbiAgICAgICAgICAgIGZjbnMudmFsaWRhdGVJbnB1dChpbnB1dCwgZm9ybUVscyk7XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5jb25zdCBmb3VuZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb3VuZCcpO1xuXG4vLy8vLy8gSUYgVEhFIENVUlJFTlQgUEFHRSBJUyBGT1VORFxuXG5pZihmb3VuZCkge1xuXG4gICAgLy9HZXR0aW5nIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgZnJvbSBVUkxTZWFyY2hQYXJhbXNcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIGNvbnN0IGxhdCA9ICtwYXJhbXMuZ2V0KCdsYXQnKTtcbiAgICBjb25zdCBsbmcgPSArcGFyYW1zLmdldCgnbG5nJyk7XG4gICAgXG4gICAgLy9GaW5kaW5nIGVsZW1lbnRzLCB3aGVyZSB0aGUgcmVzdWx0Y29vcmRzIHdpbGwgYmUgcmVuZGVyZWRcbiAgICBjb25zdCBsYXRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb3VuZF9fY29vcmQtbGF0Jyk7XG4gICAgY29uc3QgbG5nRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm91bmRfX2Nvb3JkLWxvbmcnKTtcbiAgICBcbiAgICAvLyBSZW5kZXJpbmcgdGhlIHJlc3VsdCBjb29yZHNcbiAgICBsYXRFbC50ZXh0Q29udGVudCA9IGxhdDtcbiAgICBsbmdFbC50ZXh0Q29udGVudCA9IGxuZztcbiAgICBcbiAgICAvLyBDcmVhdGluZyBhIG1hcCB3aXRoIHJlc3VsdCBjb29yZHMgaW4gdGhlIGNlbnRlclxuXG4gICAgdHJ5IHtcblxuICAgICAgICAvL1JlbmRlcmluZyBtYXBcbiAgICAgICAgZmNucy5jcmVhdGVNYXAobG5nLCBsYXQpO1xuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG5cbiAgICAgICAgY29uc3QgZXJyb3JEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3InKTsgXG4gICAgICAgIGVycm9yRGl2LnRleHRDb250ZW50ID0gJ05lcG9kYcWZaWxvIHNlIHrDrXNrYXQgbWFwdS4gWmt1c3RlIHRvIHpub3Z1IHBvemTEm2ppLidcblxuICAgIH1cbiAgIFxuICAgIC8vIFdoZW4gdXNlciBjbGlja3MgdGhlIGJ1dHRvbiwgaGUgZ2V0cyByZWRpcmVjdGVkIHRvIGluZGV4Lmh0bWxcbiAgICBjb25zdCBuZXh0VHJpcEJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbicpO1xuICAgIG5leHRUcmlwQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAvdmlld3NgLCBkb2N1bWVudC5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICB9KVxufVxuXG4gICAgXG4gICAgXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4iXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///0\\n\")}]);","extractedComments":[]}