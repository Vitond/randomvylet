!function(n){var g={};function t(e){if(g[e])return g[e].exports;var I=g[e]={i:e,l:!1,exports:{}};return n[e].call(I.exports,I,I.exports,t),I.l=!0,I.exports}t.m=n,t.c=g,t.d=function(n,g,e){t.o(n,g)||Object.defineProperty(n,g,{enumerable:!0,get:e})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,g){if(1&g&&(n=t(n)),8&g)return n;if(4&g&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(t.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&g&&"string"!=typeof n)for(var I in n)t.d(e,I,function(g){return n[g]}.bind(null,I));return e},t.n=function(n){var g=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(g,"a",g),g},t.o=function(n,g){return Object.prototype.hasOwnProperty.call(n,g)},t.p="",t(t.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/js/functions.js\n// Rendering the element or removing it from the screen smoothly - with animations\n// The element must have 3 CSS Classes available - hidden class, visible class, hiding class\n// Hidden class - display: none, no animation\n// Visible class - display: block (or whatever except none) and an animation of the element appearing on the page (sliding -in or so)\n// Hiding class - animation of the element disappearing\n// Element has only one of these classes at a time.\n// The hiding class is changed to hidden class after 'animationend' event on the element\nconst showOrHideEl = (element, hiddenClass, visibleClass, hidingClass) => {\n    if([...element.classList].includes(hiddenClass)) {\n\n        element.classList.remove(hiddenClass);\n        element.classList.add(visibleClass);\n\n    } else {\n\n        element.classList.remove(visibleClass);\n        element.classList.add(hidingClass);\n\n        const animationEndHandler =  function(event) {\n        if(event.pseudoElement) {\n            element.addEventListener('animationend', animationEndHandler,  {\n            capture: false,\n            once: true,\n            passive: false\n            });\n            return;\n        }\n\n        element.classList.remove(hidingClass);\n        element.classList.add(hiddenClass);\n\n        }\n\n        element.addEventListener('animationend', animationEndHandler, {\n        capture: false,\n        once: true,\n        passive: false\n        });\n    }\n}\n\n// Renders map to an element with id 'map'\nfunction createMap(lng, lat) {\n    \n    const pos = {'lat': lat, 'lng': lng};\n    \n    const map = new google.maps.Map(document.getElementById('map'), {\n      zoom: 12,\n      center: pos\n    });\n    \n    const marker = new google.maps.Marker({\n      position: pos,\n      map: map\n    });\n   \n  } \n\n// Sends request to Google Geocoding API and returns coords for the sent address\nconst getCoordsFromAddress = async (address) => {\n\n    // Encoding address for URL usage\n    const urlAddress = encodeURI(address);\n\n    // Sending request\n    const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?address=${urlAddress},+Mountain+View,+CA&key=AIzaSyDmi1OHuKzeuT3xbKkcgBQ4C6FEC9CN6hE`);\n    //Parsing\n    const data = await response.json();\n\n    // Returning coords for the best result\n    const coordinates = data.results[0].geometry.location;\n\n    if(!coordinates) {\n        throw new Error('Getting the coords from google geocoding API failed');\n    }\n\n    return coordinates;\n}\n\n// Converting kilometers to deg (1 deg means cca 111km)\nconst convertKmToDeg = kilometers => kilometers/111;\n\n// Switching input whenever the user chooses his preferable input option by adding and removing hidden classes\nconst changeInputType = (firstInputSet, secondInputSet, checkfor , e) => {\n\n    if (e.target.value === checkfor) {\n        firstInputSet.classList.remove('hidden');\n        secondInputSet.classList.add('hidden');\n       \n    } else {\n        firstInputSet.classList.add('hidden');\n        secondInputSet.classList.remove('hidden');\n    }\n\n}\n\n// Getting coordinates from the user input\nconst getCoords = async (addressRadio, formEls) => {\n\n    let lng;\n    let lat;\n\n    // If !adressRadio.checked = if the user has selected coords for getting address\n    if(!addressRadio.checked) {\n\n        // Getiting coords from the coords input\n        lng = +formEls['coord-long'].value;\n        lat = +formEls['coord-lat'].value;\n\n    } else {\n\n        //Getting address from the address input \n        const address = formEls['address'].value;\n\n        // Sending request to the Google Geocoding API and geting coords for the address\n        try {\n            const coords = await getCoordsFromAddress(address);\n\n            lng = coords.lng;\n            lat = coords.lat;\n\n        } catch (err) {\n            throw new Error(err);\n        }\n       \n    }\n\n    return [lng, lat];\n}\n\nconst calculateCoordTransform = (circleRadio, formEls, coords) => {\n\n    const [lat, lng] = coords;\n\n    let range;\n    let randomDist;\n\n    // Selecting random angle\n    const randomAngle  = Math.random() * 2 * Math.PI\n\n    //If circleRadio.checked = if the user has choosen the circle\n    if(circleRadio.checked) {\n\n        // Selecting random distance from base in the selected circle range\n        range = +formEls['circle-perimeter'].value;\n        randomDist = range * Math.random();\n        \n    } else {\n\n        // Selecting random distance from base in the selected annulus range\n        range = +formEls['annulus-perimeter-outer'].value - +formEls['annulus-perimeter-inner'].value;\n        randomDist = +formEls['annulus-perimeter-inner'].value + range * Math.random();\n\n    }\n\n    // Getting the offset from base latitude and base longitude in kilometers\n    const moveLngKm = Math.sin(randomAngle)*randomDist;\n    const moveLatKm = Math.cos(randomAngle)*randomDist;\n\n    // Converting to degrees\n    const moveLng = convertKmToDeg(moveLngKm);\n    const moveLat = convertKmToDeg(moveLatKm);\n\n    // Applying the offset\n    const finalLng = lng + moveLng;\n    const finalLat = lat + moveLat;\n\n    return [finalLat, finalLng];\n\n}\n\n// Adds invalid class if the input isnt valid, returns true || false , depending on if the input is valid or not\nconst validateInput = (input, formEls) => {\n\n    // Returning if the input type is radio\n    if(input.type === 'radio') {\n        return;\n    }\n\n    let valid;\n\n    // If the input is address, checking if it is not an empty string\n    // If the input is not address, checking, if the input value is a number \n    if(input === formEls['address']) {\n        valid = input.value.trim();\n    } else {\n        const numberRegex = /^[0-9]+(\\.[0-9])*$/;\n        valid = numberRegex.test(input.value);\n    }\n\n    // Adding invalid class if the input is invalid, removing it, if the input is not\n    if (valid) {\n        input.classList.remove('invalid');\n    } else {\n        input.classList.add('invalid');\n    }\n\n    return valid;\n}\n\n// Validates all inputs, that are required to create map. Takes into account, which inputs has user selected. Returns false, when at least one of the required inputs is invalid.\nconst validateNeeded = (addressRadio, circleRadio, formEls) => {\n\n\n    let validateList = [];\n\n    // Adding address to validateList, if the user has chosen address. If not, adding coords to validateList\n    if (addressRadio.checked) {\n        validateList.push(formEls['address']);\n    } else {\n        validateList.push(formEls['coord-long']);\n        validateList.push(formEls['coord-lat']);\n    }\n\n    //Adding circle-perimeter to validateList, if the user has chosen circle. If not, adding annulus-perimeter-outer and annulus-perimeter-inner to validateList.\n    if (circleRadio.checked) {\n        validateList.push(formEls['circle-perimeter']);\n    } else {\n        validateList.push(formEls['annulus-perimeter-outer']);\n        validateList.push(formEls['annulus-perimeter-inner']);\n    }\n\n    let valid = true;\n\n    // Validating every input that is listed on validateList. If any of the inputs is invalid, setting valid to false, which signifies, that the validation has failed.\n    for (const input of validateList) {\n        \n        const isInputValid = validateInput(input, formEls);\n\n        if(!isInputValid) {\n            valid = false;\n        }\n\n    }\n\n    return valid;\n}\n\n// Shows error in a div with id 'error'\nconst showError = (msg) => {\n    \n    const errorDiv = document.getElementById('error'); \n    errorDiv.textContent = msg;\n    errorDiv.style.display = 'block';\n\n}\n\n// CONCATENATED MODULE: ./src/js/index.js\n\n\ntry {\n\n\nconst form = document.querySelector('form');\n\n////// IF THE CURRENT PAGE IS INDEX\nif(form) {\n\n    // Accessing formEls \n    const formEls = form.elements;\n\n    // Selecting address initially, getting adressRadio, which is then being used for getting input values\n    const addressRadio = document.getElementById('locationselect-adr');\n    addressRadio.checked = true;\n\n    // Selecting circle initially , getting circleRadio, which is then being used for getting input values\n    const circleRadio = document.getElementById('rangeselect-circle');\n    circleRadio.checked = true;\n\n    // Setting up the refresh map button\n    const refreshBtn = document.getElementById('refresh');\n    refreshBtn.addEventListener('click', async () => {\n\n        const formEls = form.elements;\n        let coords;\n        \n        try {\n\n            //Getting coords\n            coords = await getCoords(addressRadio, formEls);\n\n        } catch (err) {\n\n           showError('Nepodařilo se získat souřadnice. Zkuste to znovu později.');\n\n            return;\n\n        }\n        try {\n\n            // Rendering map to the screen\n            createMap(...coords);\n\n        } catch {\n\n            showError('Nepodařilo se získat mapu. Zkuste to znovu později.');\n\n        }\n    })\n\n    //Showing the proper input(s) whenever the user chooses if he wants to get the base location by adress or by coords\n    const locationSelect  = document.getElementById('locationselect-adr').parentElement.parentElement;\n    const addressInputSet = document.getElementById('address').closest('.form__set');\n    const coordInputSet = document.getElementById('coord-lat').closest('.form__set');\n\n    locationSelect.addEventListener('input', (e) => {\n        changeInputType(addressInputSet, coordInputSet, 'adr', e);\n    })\n\n    //Showing the proper input(s) whenever the user chooses if he wants to find a trip place in a circle or in an annulus\n    const rangeSelect = document.getElementById('rangeselect-circle').parentElement.parentElement;\n    const annulusInputSet = document.getElementById('annulus-perimeter-outer').closest('.form__set');\n    const circleInputSet = document.getElementById('circle-perimeter').closest('.form__set');\n\n    rangeSelect.addEventListener('input', (e) => {\n        changeInputType(annulusInputSet, circleInputSet, 'annulus', e);\n    })\n\n    //Form submit handling\n    form.addEventListener('submit', async (e) => {\n\n        e.preventDefault();\n\n        // Finding out, if all needet inputs are valid\n        const areInputsValid = validateNeeded(addressRadio, circleRadio, formEls);\n\n        // Executing logic when all needed inputs are valid\n        if  (areInputsValid) {\n\n            // Getting coords for the selected base\n            let coords;\n\n            try {\n\n                //Getting coords\n                coords = await getCoords(addressRadio, formEls);\n    \n            } catch (err) {\n    \n                showError('Nepodařilo se získat souřadnice. Zkuste to znovu později.');\n\n                return;\n    \n            }\n            \n            // Getting coords of a random place in the selected range\n            const [finalLng, finalLat] = calculateCoordTransform(circleRadio, formEls, coords);\n            \n            // Constructing URL and redirecting the user to the 'found' page\n            const url = new URL(`/views/found.html?lng=${finalLng}&lat=${finalLat}`, document.location.href);\n            document.location.href = url;\n\n        } else {\n\n            if (addressRadio.checked) {\n                showError('Alespoň jeden input je neplatný. Zkontrolujte, prosím, zda jste zadali adresu a zda jsou všechna čísla zadaná bez jednotek a případné desetinné řády jsou oddělené tečkou.');\n            } else {\n                showError('Alespoň jeden input je neplatný. Zkontrolujte, prosím, zda jsou všechna čísla zadaná bez jednotek a případné desetinné řády jsou oddělené tečkou');\n            }\n\n        }\n    })\n\n    // Validating input, whenever the user enters sth to it\n    for (const input of form.elements) {\n        input.addEventListener('input', () => {\n            validateInput(input, formEls);\n        })\n    }\n}\n\nconst found = document.querySelector('.found');\n\n////// IF THE CURRENT PAGE IS FOUND\n\nif(found) {\n\n    //Getting longitude and latitude from URLSearchParams\n    const params = new URLSearchParams(window.location.search);\n    const lat = +params.get('lat');\n    const lng = +params.get('lng');\n    \n    //Finding elements, where the resultcoords will be rendered\n    const latEl = document.querySelector('.found__coord-lat');\n    const lngEl = document.querySelector('.found__coord-long');\n    \n    // Rendering the result coords\n    latEl.textContent = lat;\n    lngEl.textContent = lng;\n    \n    // Creating a map with result coords in the center\n\n    try {\n\n        //Rendering map\n        createMap(lng, lat);\n\n    } catch (err) {\n\n        showError('Nepodařilo se získat mapu. Zkuste to znovu později.');\n\n    }\n   \n    // When user clicks the button, he gets redirected to index.html\n    const nextTripBtn = document.getElementById('btn-next-trip');\n    nextTripBtn.addEventListener('click', () => {\n        const url = new URL(`/views`, document.location.href);\n        document.location.href = url;\n    })\n}\n///// EXECUTING ON BOTH PAGES\n\n // Activating show info about the application button\n const info = document.getElementById('info');\n const infoBtn = document.getElementById('show-info');\n infoBtn.addEventListener('click', () => {\n     showOrHideEl(info, 'info--hidden', 'info--visible', 'info--hiding'); // Changes button styling\n     showOrHideEl(infoBtn, 'header__btn--not-clicked', 'header__btn--clicked', 'header__btn--hiding'); //Shows or hides the info div\n })\n    \n} catch (err) {\n    showError('Váš prohlížeč zřejmě nepodporuje všechny prvky, které při kódování této aplikace používám. Z toho důvodu je možné, že aplikace nebude fungovat tak, jak by měla.')\n}\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9mdW5jdGlvbnMuanM/YmUwNCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaW5kZXguanM/N2JhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZW5kZXJpbmcgdGhlIGVsZW1lbnQgb3IgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgc2NyZWVuIHNtb290aGx5IC0gd2l0aCBhbmltYXRpb25zXG4vLyBUaGUgZWxlbWVudCBtdXN0IGhhdmUgMyBDU1MgQ2xhc3NlcyBhdmFpbGFibGUgLSBoaWRkZW4gY2xhc3MsIHZpc2libGUgY2xhc3MsIGhpZGluZyBjbGFzc1xuLy8gSGlkZGVuIGNsYXNzIC0gZGlzcGxheTogbm9uZSwgbm8gYW5pbWF0aW9uXG4vLyBWaXNpYmxlIGNsYXNzIC0gZGlzcGxheTogYmxvY2sgKG9yIHdoYXRldmVyIGV4Y2VwdCBub25lKSBhbmQgYW4gYW5pbWF0aW9uIG9mIHRoZSBlbGVtZW50IGFwcGVhcmluZyBvbiB0aGUgcGFnZSAoc2xpZGluZyAtaW4gb3Igc28pXG4vLyBIaWRpbmcgY2xhc3MgLSBhbmltYXRpb24gb2YgdGhlIGVsZW1lbnQgZGlzYXBwZWFyaW5nXG4vLyBFbGVtZW50IGhhcyBvbmx5IG9uZSBvZiB0aGVzZSBjbGFzc2VzIGF0IGEgdGltZS5cbi8vIFRoZSBoaWRpbmcgY2xhc3MgaXMgY2hhbmdlZCB0byBoaWRkZW4gY2xhc3MgYWZ0ZXIgJ2FuaW1hdGlvbmVuZCcgZXZlbnQgb24gdGhlIGVsZW1lbnRcbmV4cG9ydCBjb25zdCBzaG93T3JIaWRlRWwgPSAoZWxlbWVudCwgaGlkZGVuQ2xhc3MsIHZpc2libGVDbGFzcywgaGlkaW5nQ2xhc3MpID0+IHtcbiAgICBpZihbLi4uZWxlbWVudC5jbGFzc0xpc3RdLmluY2x1ZGVzKGhpZGRlbkNsYXNzKSkge1xuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShoaWRkZW5DbGFzcyk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCh2aXNpYmxlQ2xhc3MpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodmlzaWJsZUNsYXNzKTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGhpZGluZ0NsYXNzKTtcblxuICAgICAgICBjb25zdCBhbmltYXRpb25FbmRIYW5kbGVyID0gIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmKGV2ZW50LnBzZXVkb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgYW5pbWF0aW9uRW5kSGFuZGxlciwgIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShoaWRpbmdDbGFzcyk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChoaWRkZW5DbGFzcyk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgYW5pbWF0aW9uRW5kSGFuZGxlciwge1xuICAgICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vLyBSZW5kZXJzIG1hcCB0byBhbiBlbGVtZW50IHdpdGggaWQgJ21hcCdcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAobG5nLCBsYXQpIHtcbiAgICBcbiAgICBjb25zdCBwb3MgPSB7J2xhdCc6IGxhdCwgJ2xuZyc6IGxuZ307XG4gICAgXG4gICAgY29uc3QgbWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFwJyksIHtcbiAgICAgIHpvb206IDEyLFxuICAgICAgY2VudGVyOiBwb3NcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBtYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKHtcbiAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICBtYXA6IG1hcFxuICAgIH0pO1xuICAgXG4gIH0gXG5cbi8vIFNlbmRzIHJlcXVlc3QgdG8gR29vZ2xlIEdlb2NvZGluZyBBUEkgYW5kIHJldHVybnMgY29vcmRzIGZvciB0aGUgc2VudCBhZGRyZXNzXG5leHBvcnQgY29uc3QgZ2V0Q29vcmRzRnJvbUFkZHJlc3MgPSBhc3luYyAoYWRkcmVzcykgPT4ge1xuXG4gICAgLy8gRW5jb2RpbmcgYWRkcmVzcyBmb3IgVVJMIHVzYWdlXG4gICAgY29uc3QgdXJsQWRkcmVzcyA9IGVuY29kZVVSSShhZGRyZXNzKTtcblxuICAgIC8vIFNlbmRpbmcgcmVxdWVzdFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9nZW9jb2RlL2pzb24/YWRkcmVzcz0ke3VybEFkZHJlc3N9LCtNb3VudGFpbitWaWV3LCtDQSZrZXk9QUl6YVN5RG1pMU9IdUt6ZXVUM3hiS2tjZ0JRNEM2RkVDOUNONmhFYCk7XG4gICAgLy9QYXJzaW5nXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgIC8vIFJldHVybmluZyBjb29yZHMgZm9yIHRoZSBiZXN0IHJlc3VsdFxuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gZGF0YS5yZXN1bHRzWzBdLmdlb21ldHJ5LmxvY2F0aW9uO1xuXG4gICAgaWYoIWNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2V0dGluZyB0aGUgY29vcmRzIGZyb20gZ29vZ2xlIGdlb2NvZGluZyBBUEkgZmFpbGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xufVxuXG4vLyBDb252ZXJ0aW5nIGtpbG9tZXRlcnMgdG8gZGVnICgxIGRlZyBtZWFucyBjY2EgMTExa20pXG5leHBvcnQgY29uc3QgY29udmVydEttVG9EZWcgPSBraWxvbWV0ZXJzID0+IGtpbG9tZXRlcnMvMTExO1xuXG4vLyBTd2l0Y2hpbmcgaW5wdXQgd2hlbmV2ZXIgdGhlIHVzZXIgY2hvb3NlcyBoaXMgcHJlZmVyYWJsZSBpbnB1dCBvcHRpb24gYnkgYWRkaW5nIGFuZCByZW1vdmluZyBoaWRkZW4gY2xhc3Nlc1xuZXhwb3J0IGNvbnN0IGNoYW5nZUlucHV0VHlwZSA9IChmaXJzdElucHV0U2V0LCBzZWNvbmRJbnB1dFNldCwgY2hlY2tmb3IgLCBlKSA9PiB7XG5cbiAgICBpZiAoZS50YXJnZXQudmFsdWUgPT09IGNoZWNrZm9yKSB7XG4gICAgICAgIGZpcnN0SW5wdXRTZXQuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgIHNlY29uZElucHV0U2V0LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0SW5wdXRTZXQuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIHNlY29uZElucHV0U2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgIH1cblxufVxuXG4vLyBHZXR0aW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHVzZXIgaW5wdXRcbmV4cG9ydCBjb25zdCBnZXRDb29yZHMgPSBhc3luYyAoYWRkcmVzc1JhZGlvLCBmb3JtRWxzKSA9PiB7XG5cbiAgICBsZXQgbG5nO1xuICAgIGxldCBsYXQ7XG5cbiAgICAvLyBJZiAhYWRyZXNzUmFkaW8uY2hlY2tlZCA9IGlmIHRoZSB1c2VyIGhhcyBzZWxlY3RlZCBjb29yZHMgZm9yIGdldHRpbmcgYWRkcmVzc1xuICAgIGlmKCFhZGRyZXNzUmFkaW8uY2hlY2tlZCkge1xuXG4gICAgICAgIC8vIEdldGl0aW5nIGNvb3JkcyBmcm9tIHRoZSBjb29yZHMgaW5wdXRcbiAgICAgICAgbG5nID0gK2Zvcm1FbHNbJ2Nvb3JkLWxvbmcnXS52YWx1ZTtcbiAgICAgICAgbGF0ID0gK2Zvcm1FbHNbJ2Nvb3JkLWxhdCddLnZhbHVlO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvL0dldHRpbmcgYWRkcmVzcyBmcm9tIHRoZSBhZGRyZXNzIGlucHV0IFxuICAgICAgICBjb25zdCBhZGRyZXNzID0gZm9ybUVsc1snYWRkcmVzcyddLnZhbHVlO1xuXG4gICAgICAgIC8vIFNlbmRpbmcgcmVxdWVzdCB0byB0aGUgR29vZ2xlIEdlb2NvZGluZyBBUEkgYW5kIGdldGluZyBjb29yZHMgZm9yIHRoZSBhZGRyZXNzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb29yZHMgPSBhd2FpdCBnZXRDb29yZHNGcm9tQWRkcmVzcyhhZGRyZXNzKTtcblxuICAgICAgICAgICAgbG5nID0gY29vcmRzLmxuZztcbiAgICAgICAgICAgIGxhdCA9IGNvb3Jkcy5sYXQ7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgIFxuICAgIH1cblxuICAgIHJldHVybiBbbG5nLCBsYXRdO1xufVxuXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlQ29vcmRUcmFuc2Zvcm0gPSAoY2lyY2xlUmFkaW8sIGZvcm1FbHMsIGNvb3JkcykgPT4ge1xuXG4gICAgY29uc3QgW2xhdCwgbG5nXSA9IGNvb3JkcztcblxuICAgIGxldCByYW5nZTtcbiAgICBsZXQgcmFuZG9tRGlzdDtcblxuICAgIC8vIFNlbGVjdGluZyByYW5kb20gYW5nbGVcbiAgICBjb25zdCByYW5kb21BbmdsZSAgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUElcblxuICAgIC8vSWYgY2lyY2xlUmFkaW8uY2hlY2tlZCA9IGlmIHRoZSB1c2VyIGhhcyBjaG9vc2VuIHRoZSBjaXJjbGVcbiAgICBpZihjaXJjbGVSYWRpby5jaGVja2VkKSB7XG5cbiAgICAgICAgLy8gU2VsZWN0aW5nIHJhbmRvbSBkaXN0YW5jZSBmcm9tIGJhc2UgaW4gdGhlIHNlbGVjdGVkIGNpcmNsZSByYW5nZVxuICAgICAgICByYW5nZSA9ICtmb3JtRWxzWydjaXJjbGUtcGVyaW1ldGVyJ10udmFsdWU7XG4gICAgICAgIHJhbmRvbURpc3QgPSByYW5nZSAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgIFxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gU2VsZWN0aW5nIHJhbmRvbSBkaXN0YW5jZSBmcm9tIGJhc2UgaW4gdGhlIHNlbGVjdGVkIGFubnVsdXMgcmFuZ2VcbiAgICAgICAgcmFuZ2UgPSArZm9ybUVsc1snYW5udWx1cy1wZXJpbWV0ZXItb3V0ZXInXS52YWx1ZSAtICtmb3JtRWxzWydhbm51bHVzLXBlcmltZXRlci1pbm5lciddLnZhbHVlO1xuICAgICAgICByYW5kb21EaXN0ID0gK2Zvcm1FbHNbJ2FubnVsdXMtcGVyaW1ldGVyLWlubmVyJ10udmFsdWUgKyByYW5nZSAqIE1hdGgucmFuZG9tKCk7XG5cbiAgICB9XG5cbiAgICAvLyBHZXR0aW5nIHRoZSBvZmZzZXQgZnJvbSBiYXNlIGxhdGl0dWRlIGFuZCBiYXNlIGxvbmdpdHVkZSBpbiBraWxvbWV0ZXJzXG4gICAgY29uc3QgbW92ZUxuZ0ttID0gTWF0aC5zaW4ocmFuZG9tQW5nbGUpKnJhbmRvbURpc3Q7XG4gICAgY29uc3QgbW92ZUxhdEttID0gTWF0aC5jb3MocmFuZG9tQW5nbGUpKnJhbmRvbURpc3Q7XG5cbiAgICAvLyBDb252ZXJ0aW5nIHRvIGRlZ3JlZXNcbiAgICBjb25zdCBtb3ZlTG5nID0gY29udmVydEttVG9EZWcobW92ZUxuZ0ttKTtcbiAgICBjb25zdCBtb3ZlTGF0ID0gY29udmVydEttVG9EZWcobW92ZUxhdEttKTtcblxuICAgIC8vIEFwcGx5aW5nIHRoZSBvZmZzZXRcbiAgICBjb25zdCBmaW5hbExuZyA9IGxuZyArIG1vdmVMbmc7XG4gICAgY29uc3QgZmluYWxMYXQgPSBsYXQgKyBtb3ZlTGF0O1xuXG4gICAgcmV0dXJuIFtmaW5hbExhdCwgZmluYWxMbmddO1xuXG59XG5cbi8vIEFkZHMgaW52YWxpZCBjbGFzcyBpZiB0aGUgaW5wdXQgaXNudCB2YWxpZCwgcmV0dXJucyB0cnVlIHx8IGZhbHNlICwgZGVwZW5kaW5nIG9uIGlmIHRoZSBpbnB1dCBpcyB2YWxpZCBvciBub3RcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUlucHV0ID0gKGlucHV0LCBmb3JtRWxzKSA9PiB7XG5cbiAgICAvLyBSZXR1cm5pbmcgaWYgdGhlIGlucHV0IHR5cGUgaXMgcmFkaW9cbiAgICBpZihpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdmFsaWQ7XG5cbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYWRkcmVzcywgY2hlY2tpbmcgaWYgaXQgaXMgbm90IGFuIGVtcHR5IHN0cmluZ1xuICAgIC8vIElmIHRoZSBpbnB1dCBpcyBub3QgYWRkcmVzcywgY2hlY2tpbmcsIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIG51bWJlciBcbiAgICBpZihpbnB1dCA9PT0gZm9ybUVsc1snYWRkcmVzcyddKSB7XG4gICAgICAgIHZhbGlkID0gaW5wdXQudmFsdWUudHJpbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG51bWJlclJlZ2V4ID0gL15bMC05XSsoXFwuWzAtOV0pKiQvO1xuICAgICAgICB2YWxpZCA9IG51bWJlclJlZ2V4LnRlc3QoaW5wdXQudmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEFkZGluZyBpbnZhbGlkIGNsYXNzIGlmIHRoZSBpbnB1dCBpcyBpbnZhbGlkLCByZW1vdmluZyBpdCwgaWYgdGhlIGlucHV0IGlzIG5vdFxuICAgIGlmICh2YWxpZCkge1xuICAgICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCdpbnZhbGlkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnaW52YWxpZCcpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZDtcbn1cblxuLy8gVmFsaWRhdGVzIGFsbCBpbnB1dHMsIHRoYXQgYXJlIHJlcXVpcmVkIHRvIGNyZWF0ZSBtYXAuIFRha2VzIGludG8gYWNjb3VudCwgd2hpY2ggaW5wdXRzIGhhcyB1c2VyIHNlbGVjdGVkLiBSZXR1cm5zIGZhbHNlLCB3aGVuIGF0IGxlYXN0IG9uZSBvZiB0aGUgcmVxdWlyZWQgaW5wdXRzIGlzIGludmFsaWQuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVOZWVkZWQgPSAoYWRkcmVzc1JhZGlvLCBjaXJjbGVSYWRpbywgZm9ybUVscykgPT4ge1xuXG5cbiAgICBsZXQgdmFsaWRhdGVMaXN0ID0gW107XG5cbiAgICAvLyBBZGRpbmcgYWRkcmVzcyB0byB2YWxpZGF0ZUxpc3QsIGlmIHRoZSB1c2VyIGhhcyBjaG9zZW4gYWRkcmVzcy4gSWYgbm90LCBhZGRpbmcgY29vcmRzIHRvIHZhbGlkYXRlTGlzdFxuICAgIGlmIChhZGRyZXNzUmFkaW8uY2hlY2tlZCkge1xuICAgICAgICB2YWxpZGF0ZUxpc3QucHVzaChmb3JtRWxzWydhZGRyZXNzJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRlTGlzdC5wdXNoKGZvcm1FbHNbJ2Nvb3JkLWxvbmcnXSk7XG4gICAgICAgIHZhbGlkYXRlTGlzdC5wdXNoKGZvcm1FbHNbJ2Nvb3JkLWxhdCddKTtcbiAgICB9XG5cbiAgICAvL0FkZGluZyBjaXJjbGUtcGVyaW1ldGVyIHRvIHZhbGlkYXRlTGlzdCwgaWYgdGhlIHVzZXIgaGFzIGNob3NlbiBjaXJjbGUuIElmIG5vdCwgYWRkaW5nIGFubnVsdXMtcGVyaW1ldGVyLW91dGVyIGFuZCBhbm51bHVzLXBlcmltZXRlci1pbm5lciB0byB2YWxpZGF0ZUxpc3QuXG4gICAgaWYgKGNpcmNsZVJhZGlvLmNoZWNrZWQpIHtcbiAgICAgICAgdmFsaWRhdGVMaXN0LnB1c2goZm9ybUVsc1snY2lyY2xlLXBlcmltZXRlciddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0ZUxpc3QucHVzaChmb3JtRWxzWydhbm51bHVzLXBlcmltZXRlci1vdXRlciddKTtcbiAgICAgICAgdmFsaWRhdGVMaXN0LnB1c2goZm9ybUVsc1snYW5udWx1cy1wZXJpbWV0ZXItaW5uZXInXSk7XG4gICAgfVxuXG4gICAgbGV0IHZhbGlkID0gdHJ1ZTtcblxuICAgIC8vIFZhbGlkYXRpbmcgZXZlcnkgaW5wdXQgdGhhdCBpcyBsaXN0ZWQgb24gdmFsaWRhdGVMaXN0LiBJZiBhbnkgb2YgdGhlIGlucHV0cyBpcyBpbnZhbGlkLCBzZXR0aW5nIHZhbGlkIHRvIGZhbHNlLCB3aGljaCBzaWduaWZpZXMsIHRoYXQgdGhlIHZhbGlkYXRpb24gaGFzIGZhaWxlZC5cbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIHZhbGlkYXRlTGlzdCkge1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaXNJbnB1dFZhbGlkID0gdmFsaWRhdGVJbnB1dChpbnB1dCwgZm9ybUVscyk7XG5cbiAgICAgICAgaWYoIWlzSW5wdXRWYWxpZCkge1xuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkO1xufVxuXG4vLyBTaG93cyBlcnJvciBpbiBhIGRpdiB3aXRoIGlkICdlcnJvcidcbmV4cG9ydCBjb25zdCBzaG93RXJyb3IgPSAobXNnKSA9PiB7XG4gICAgXG4gICAgY29uc3QgZXJyb3JEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3InKTsgXG4gICAgZXJyb3JEaXYudGV4dENvbnRlbnQgPSBtc2c7XG4gICAgZXJyb3JEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbn1cbiIsImltcG9ydCAqIGFzIGZjbnMgZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuXG50cnkge1xuXG5cbmNvbnN0IGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdmb3JtJyk7XG5cbi8vLy8vLyBJRiBUSEUgQ1VSUkVOVCBQQUdFIElTIElOREVYXG5pZihmb3JtKSB7XG5cbiAgICAvLyBBY2Nlc3NpbmcgZm9ybUVscyBcbiAgICBjb25zdCBmb3JtRWxzID0gZm9ybS5lbGVtZW50cztcblxuICAgIC8vIFNlbGVjdGluZyBhZGRyZXNzIGluaXRpYWxseSwgZ2V0dGluZyBhZHJlc3NSYWRpbywgd2hpY2ggaXMgdGhlbiBiZWluZyB1c2VkIGZvciBnZXR0aW5nIGlucHV0IHZhbHVlc1xuICAgIGNvbnN0IGFkZHJlc3NSYWRpbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbnNlbGVjdC1hZHInKTtcbiAgICBhZGRyZXNzUmFkaW8uY2hlY2tlZCA9IHRydWU7XG5cbiAgICAvLyBTZWxlY3RpbmcgY2lyY2xlIGluaXRpYWxseSAsIGdldHRpbmcgY2lyY2xlUmFkaW8sIHdoaWNoIGlzIHRoZW4gYmVpbmcgdXNlZCBmb3IgZ2V0dGluZyBpbnB1dCB2YWx1ZXNcbiAgICBjb25zdCBjaXJjbGVSYWRpbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyYW5nZXNlbGVjdC1jaXJjbGUnKTtcbiAgICBjaXJjbGVSYWRpby5jaGVja2VkID0gdHJ1ZTtcblxuICAgIC8vIFNldHRpbmcgdXAgdGhlIHJlZnJlc2ggbWFwIGJ1dHRvblxuICAgIGNvbnN0IHJlZnJlc2hCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVmcmVzaCcpO1xuICAgIHJlZnJlc2hCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgZm9ybUVscyA9IGZvcm0uZWxlbWVudHM7XG4gICAgICAgIGxldCBjb29yZHM7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAvL0dldHRpbmcgY29vcmRzXG4gICAgICAgICAgICBjb29yZHMgPSBhd2FpdCBmY25zLmdldENvb3JkcyhhZGRyZXNzUmFkaW8sIGZvcm1FbHMpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuXG4gICAgICAgICAgIGZjbnMuc2hvd0Vycm9yKCdOZXBvZGHFmWlsbyBzZSB6w61za2F0IHNvdcWZYWRuaWNlLiBaa3VzdGUgdG8gem5vdnUgcG96ZMSbamkuJyk7XG5cbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIC8vIFJlbmRlcmluZyBtYXAgdG8gdGhlIHNjcmVlblxuICAgICAgICAgICAgZmNucy5jcmVhdGVNYXAoLi4uY29vcmRzKTtcblxuICAgICAgICB9IGNhdGNoIHtcblxuICAgICAgICAgICAgZmNucy5zaG93RXJyb3IoJ05lcG9kYcWZaWxvIHNlIHrDrXNrYXQgbWFwdS4gWmt1c3RlIHRvIHpub3Z1IHBvemTEm2ppLicpO1xuXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLy9TaG93aW5nIHRoZSBwcm9wZXIgaW5wdXQocykgd2hlbmV2ZXIgdGhlIHVzZXIgY2hvb3NlcyBpZiBoZSB3YW50cyB0byBnZXQgdGhlIGJhc2UgbG9jYXRpb24gYnkgYWRyZXNzIG9yIGJ5IGNvb3Jkc1xuICAgIGNvbnN0IGxvY2F0aW9uU2VsZWN0ICA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2NhdGlvbnNlbGVjdC1hZHInKS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgY29uc3QgYWRkcmVzc0lucHV0U2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZHJlc3MnKS5jbG9zZXN0KCcuZm9ybV9fc2V0Jyk7XG4gICAgY29uc3QgY29vcmRJbnB1dFNldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb29yZC1sYXQnKS5jbG9zZXN0KCcuZm9ybV9fc2V0Jyk7XG5cbiAgICBsb2NhdGlvblNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG4gICAgICAgIGZjbnMuY2hhbmdlSW5wdXRUeXBlKGFkZHJlc3NJbnB1dFNldCwgY29vcmRJbnB1dFNldCwgJ2FkcicsIGUpO1xuICAgIH0pXG5cbiAgICAvL1Nob3dpbmcgdGhlIHByb3BlciBpbnB1dChzKSB3aGVuZXZlciB0aGUgdXNlciBjaG9vc2VzIGlmIGhlIHdhbnRzIHRvIGZpbmQgYSB0cmlwIHBsYWNlIGluIGEgY2lyY2xlIG9yIGluIGFuIGFubnVsdXNcbiAgICBjb25zdCByYW5nZVNlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyYW5nZXNlbGVjdC1jaXJjbGUnKS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgY29uc3QgYW5udWx1c0lucHV0U2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FubnVsdXMtcGVyaW1ldGVyLW91dGVyJykuY2xvc2VzdCgnLmZvcm1fX3NldCcpO1xuICAgIGNvbnN0IGNpcmNsZUlucHV0U2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NpcmNsZS1wZXJpbWV0ZXInKS5jbG9zZXN0KCcuZm9ybV9fc2V0Jyk7XG5cbiAgICByYW5nZVNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG4gICAgICAgIGZjbnMuY2hhbmdlSW5wdXRUeXBlKGFubnVsdXNJbnB1dFNldCwgY2lyY2xlSW5wdXRTZXQsICdhbm51bHVzJywgZSk7XG4gICAgfSlcblxuICAgIC8vRm9ybSBzdWJtaXQgaGFuZGxpbmdcbiAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGFzeW5jIChlKSA9PiB7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIEZpbmRpbmcgb3V0LCBpZiBhbGwgbmVlZGV0IGlucHV0cyBhcmUgdmFsaWRcbiAgICAgICAgY29uc3QgYXJlSW5wdXRzVmFsaWQgPSBmY25zLnZhbGlkYXRlTmVlZGVkKGFkZHJlc3NSYWRpbywgY2lyY2xlUmFkaW8sIGZvcm1FbHMpO1xuXG4gICAgICAgIC8vIEV4ZWN1dGluZyBsb2dpYyB3aGVuIGFsbCBuZWVkZWQgaW5wdXRzIGFyZSB2YWxpZFxuICAgICAgICBpZiAgKGFyZUlucHV0c1ZhbGlkKSB7XG5cbiAgICAgICAgICAgIC8vIEdldHRpbmcgY29vcmRzIGZvciB0aGUgc2VsZWN0ZWQgYmFzZVxuICAgICAgICAgICAgbGV0IGNvb3JkcztcblxuICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgIC8vR2V0dGluZyBjb29yZHNcbiAgICAgICAgICAgICAgICBjb29yZHMgPSBhd2FpdCBmY25zLmdldENvb3JkcyhhZGRyZXNzUmFkaW8sIGZvcm1FbHMpO1xuICAgIFxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgZmNucy5zaG93RXJyb3IoJ05lcG9kYcWZaWxvIHNlIHrDrXNrYXQgc291xZlhZG5pY2UuIFprdXN0ZSB0byB6bm92dSBwb3pkxJtqaS4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0dGluZyBjb29yZHMgb2YgYSByYW5kb20gcGxhY2UgaW4gdGhlIHNlbGVjdGVkIHJhbmdlXG4gICAgICAgICAgICBjb25zdCBbZmluYWxMbmcsIGZpbmFsTGF0XSA9IGZjbnMuY2FsY3VsYXRlQ29vcmRUcmFuc2Zvcm0oY2lyY2xlUmFkaW8sIGZvcm1FbHMsIGNvb3Jkcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdGluZyBVUkwgYW5kIHJlZGlyZWN0aW5nIHRoZSB1c2VyIHRvIHRoZSAnZm91bmQnIHBhZ2VcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYC92aWV3cy9mb3VuZC5odG1sP2xuZz0ke2ZpbmFsTG5nfSZsYXQ9JHtmaW5hbExhdH1gLCBkb2N1bWVudC5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKGFkZHJlc3NSYWRpby5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgZmNucy5zaG93RXJyb3IoJ0FsZXNwb8WIIGplZGVuIGlucHV0IGplIG5lcGxhdG7DvS4gWmtvbnRyb2x1anRlLCBwcm9zw61tLCB6ZGEganN0ZSB6YWRhbGkgYWRyZXN1IGEgemRhIGpzb3UgdsWhZWNobmEgxI3DrXNsYSB6YWRhbsOhIGJleiBqZWRub3RlayBhIHDFmcOtcGFkbsOpIGRlc2V0aW5uw6kgxZnDoWR5IGpzb3Ugb2RkxJtsZW7DqSB0ZcSNa291LicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmY25zLnNob3dFcnJvcignQWxlc3BvxYggamVkZW4gaW5wdXQgamUgbmVwbGF0bsO9LiBaa29udHJvbHVqdGUsIHByb3PDrW0sIHpkYSBqc291IHbFoWVjaG5hIMSNw61zbGEgemFkYW7DoSBiZXogamVkbm90ZWsgYSBwxZnDrXBhZG7DqSBkZXNldGlubsOpIMWZw6FkeSBqc291IG9kZMSbbGVuw6kgdGXEjWtvdScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVmFsaWRhdGluZyBpbnB1dCwgd2hlbmV2ZXIgdGhlIHVzZXIgZW50ZXJzIHN0aCB0byBpdFxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgZm9ybS5lbGVtZW50cykge1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcbiAgICAgICAgICAgIGZjbnMudmFsaWRhdGVJbnB1dChpbnB1dCwgZm9ybUVscyk7XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5jb25zdCBmb3VuZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb3VuZCcpO1xuXG4vLy8vLy8gSUYgVEhFIENVUlJFTlQgUEFHRSBJUyBGT1VORFxuXG5pZihmb3VuZCkge1xuXG4gICAgLy9HZXR0aW5nIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgZnJvbSBVUkxTZWFyY2hQYXJhbXNcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIGNvbnN0IGxhdCA9ICtwYXJhbXMuZ2V0KCdsYXQnKTtcbiAgICBjb25zdCBsbmcgPSArcGFyYW1zLmdldCgnbG5nJyk7XG4gICAgXG4gICAgLy9GaW5kaW5nIGVsZW1lbnRzLCB3aGVyZSB0aGUgcmVzdWx0Y29vcmRzIHdpbGwgYmUgcmVuZGVyZWRcbiAgICBjb25zdCBsYXRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb3VuZF9fY29vcmQtbGF0Jyk7XG4gICAgY29uc3QgbG5nRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm91bmRfX2Nvb3JkLWxvbmcnKTtcbiAgICBcbiAgICAvLyBSZW5kZXJpbmcgdGhlIHJlc3VsdCBjb29yZHNcbiAgICBsYXRFbC50ZXh0Q29udGVudCA9IGxhdDtcbiAgICBsbmdFbC50ZXh0Q29udGVudCA9IGxuZztcbiAgICBcbiAgICAvLyBDcmVhdGluZyBhIG1hcCB3aXRoIHJlc3VsdCBjb29yZHMgaW4gdGhlIGNlbnRlclxuXG4gICAgdHJ5IHtcblxuICAgICAgICAvL1JlbmRlcmluZyBtYXBcbiAgICAgICAgZmNucy5jcmVhdGVNYXAobG5nLCBsYXQpO1xuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG5cbiAgICAgICAgZmNucy5zaG93RXJyb3IoJ05lcG9kYcWZaWxvIHNlIHrDrXNrYXQgbWFwdS4gWmt1c3RlIHRvIHpub3Z1IHBvemTEm2ppLicpO1xuXG4gICAgfVxuICAgXG4gICAgLy8gV2hlbiB1c2VyIGNsaWNrcyB0aGUgYnV0dG9uLCBoZSBnZXRzIHJlZGlyZWN0ZWQgdG8gaW5kZXguaHRtbFxuICAgIGNvbnN0IG5leHRUcmlwQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bi1uZXh0LXRyaXAnKTtcbiAgICBuZXh0VHJpcEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgL3ZpZXdzYCwgZG9jdW1lbnQubG9jYXRpb24uaHJlZik7XG4gICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgfSlcbn1cbi8vLy8vIEVYRUNVVElORyBPTiBCT1RIIFBBR0VTXG5cbiAvLyBBY3RpdmF0aW5nIHNob3cgaW5mbyBhYm91dCB0aGUgYXBwbGljYXRpb24gYnV0dG9uXG4gY29uc3QgaW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbmZvJyk7XG4gY29uc3QgaW5mb0J0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG93LWluZm8nKTtcbiBpbmZvQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICBmY25zLnNob3dPckhpZGVFbChpbmZvLCAnaW5mby0taGlkZGVuJywgJ2luZm8tLXZpc2libGUnLCAnaW5mby0taGlkaW5nJyk7IC8vIENoYW5nZXMgYnV0dG9uIHN0eWxpbmdcbiAgICAgZmNucy5zaG93T3JIaWRlRWwoaW5mb0J0biwgJ2hlYWRlcl9fYnRuLS1ub3QtY2xpY2tlZCcsICdoZWFkZXJfX2J0bi0tY2xpY2tlZCcsICdoZWFkZXJfX2J0bi0taGlkaW5nJyk7IC8vU2hvd3Mgb3IgaGlkZXMgdGhlIGluZm8gZGl2XG4gfSlcbiAgICBcbn0gY2F0Y2ggKGVycikge1xuICAgIGZjbnMuc2hvd0Vycm9yKCdWw6HFoSBwcm9obMOtxb5lxI0gesWZZWptxJsgbmVwb2Rwb3J1amUgdsWhZWNobnkgcHJ2a3ksIGt0ZXLDqSBwxZlpIGvDs2RvdsOhbsOtIHTDqXRvIGFwbGlrYWNlIHBvdcW+w612w6FtLiBaIHRvaG8gZMWvdm9kdSBqZSBtb8W+bsOpLCDFvmUgYXBsaWthY2UgbmVidWRlIGZ1bmdvdmF0IHRhaywgamFrIGJ5IG3Em2xhLicpXG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4iXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);